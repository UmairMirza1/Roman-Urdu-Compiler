TRANSLATION SCHEME


Program →  D Program | ^ 

D → Code | Function | Koment 

Code → Statement Code | If Code | While Code | ^

Statement → Stmt Comment
Stmt → Variable | Input | Output | Return | Chalao

Function →  kaam ID @ FuncT ( PL ) karo Koment Code kaam khatam Koment
FuncT -> khali | adad 
PL → ID @ adad MPL  | ^
MPL → | PL   | ^

==============Rakho=========================
Variable → rakho ID Type { R.id = Id.lex } R 
Type → @ adad  | ^  
R → := Val { 
emit(R.id+”=”+ Val.v); 
R.v =SymbolTable.add(R.id, INT);  }
|  ^ {  R.v = SymbolTable.add(R.id, INT);  }
w
Val → ID { Val.v=ID.lex; }
 | Integer { Val.v=Integer.lex; }
 | Exp { Val.v=Exp.v; } 
| Chalao {Val.v=Chalao.v}

========================================

Condition → Exp RO  Exp  { Condition.Value =  Exp.ex + Ro.lex + Exp.ex } 

========================================     




Exp → T - Exp1 {
var=newTemp();
SymbolTable.add(var, INT);
emit(var+’=’+T.val+’-’+Exp1.val);
Exp.val=var   
Exp.ex = T.val + “-” + exp1.ex 
}

                          
Exp → T + Exp2{
var=newTemp();
SymbolTable.add(var, INT);
emit(var+’=’+T.val+’+’+Exp2.val);
Exp.val=var; 
Exp.ex = T.val + “-” + exp1.ex 
}

Exp → T {Exp.val=T.val;}
    
T →  L% T1 {
var=newTemp();
SymbolTable.add(var, INT);
emit(var+’=’+L.val+’%’+T1.val);
T.val=var;
T.ex=L.val+”%”+T1.ex;
}
                    
T →  L /  T2 {
var=newTemp();
SymbolTable.add(var, INT);
emit(var+’=’+L.val+’/’+T2.val);
T.val=var;
T.ex=L.val+”/”+T2.ex;
}
                    
                    
T →  L*  T3 {
var=newTemp();
SymbolTable.add(var, INT);
emit(var+’=’+L.val+’*’+T3.val);
T.val=var;
T.ex=L.val+”*”+T3.ex;
 }
  
T →  L  {T.val=L.val; T.ex=L.val}
L → ID  { L.val=ID.lex; }
L → Integer   { L.val=Integer.lex; }

=======================================

Chalao →  chalao ID { PLF.i=0; } ( PLF ) { 
var=newTemp(); 
emit (“call” + ID.lex + PLF.v + “,” +var);
Chalao.v = var;
}
PLF → ID {
 emit(“param ”+ ID.lex);
 PLF.i = PLF.i +1;   // +1
 MPLF.i = PLF.i;
 } MPLF { PLF.v = MPLF.v; }  


PLF → Integer {
emit (“param”+Integer.lex);
PLF.i=PLF.i+1; 
MPLF.i = PLF.i;
} MPLF { PLF.v =MPLF.v; } 
PLF → ^  { PLF.v = PLF.i ;}
MPLF → | { PLF.i = MPLF.i ;} PLF  {MPLF.v = PLF.v;}    
MPLF → ^ { MPLF.v = MPLF.i ;} 


========================================

Koment → Comment  | ^

========================================

IF    →  agar ( Condition ) to phir karo { 
lnTrue= n ;
emit ( “if” + Condition.v + goto + __ ) ;
lnFalse= n;
Emit ( “goto” + __ )
BackPatch(lnTrue)
} 
Koment
Code { 
IF_end= ln;
emit ( goto __)
BackPatch(lnFalse) 
}
WG 
WP 
bas karo 
{ 
BackPatch( IF_end )
BackPatch(WG.val) 
}
Koment
WG  →  warna agar Condition to phir Koment {
lnTrue_= n;
emit ( “if” + Condition.v + goto + __ ) ;
lnFalse_ = n;
emit( goto __)
BackPatch(lnTrue_) 
 } 
Code  { 
WG.v= ln;  // storing the current line number for Branch Ending
emit (goto __ )
BackPatch(lnFalse_)
 }
WG  →  ^
WP  →  warna phir Koment  Code 
WP  →   ^

========================================




Return-> wapis bhaijo Val { emit (“ret” + Val.v) }

// Todo : Add cascading to it

Input → lo   InputMsg  >> ID { emit(“in”+ID.v+”\n”) }   
InputMsg → ^ 
InputMsg → << String  { emit (“out” +String .v +”\n”) }


Output →  dekhao <<  OutVal  { emit (“out” + OutVal.v +”\n” ) } MoreOut 
MoreOut → << OutVal MoreOut { emit ( “out” + OutVal.v +”\n” )  }  
MoreOut →^
OutVal → String { String.lex } | Val { Val.v }


Note:  Backpatch has global access to ln, so it patches current line number at the parameter passed to it 

While →  jab tak ( Condition )  karo Koment   
{  
lnTrue = n ;
emit (“if” + Condition.Value goto __  ); 
lnFalse = n;
Emit (goto __ ) 
BackPatch(lnTrue)} 
Code  
{ emit( “goto” + lnTrue) }
bas karo { BackPatch(lnFalse) } 
Koment


